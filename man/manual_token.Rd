% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/token_manual.R
\docType{class}
\name{AzureManualToken}
\alias{AzureManualToken}
\alias{get_manual_token}
\title{Manual Azure Token}
\format{
An R6 object of class \code{AzureManualToken}, inheriting from \code{AzureToken}.
}
\usage{
get_manual_token(token, type = "Bearer", tenant = NULL, resource = NULL)
}
\arguments{
\item{token}{A character string containing the access token.}

\item{type}{The token type, usually "Bearer".}

\item{tenant}{Optional tenant ID. If NULL, will be extracted from JWT claims if possible.}

\item{resource}{Optional resource/audience URL or GUID. If NULL, will be extracted from
JWT claims if possible.}
}
\value{
An object of class \code{AzureManualToken}, inheriting from \code{AzureToken}.
}
\description{
Create an Azure token object from a pre-existing access token string. This is useful
when you have obtained a token externally (e.g., via Azure CLI, Python, or another
authentication mechanism) and want to use it with the AzureR ecosystem.
}
\details{
The \code{AzureManualToken} class provides a way to wrap an externally-obtained access
token string so it can be used with packages like \code{AzureGraph}, \code{AzureRMR},
and other AzureR family packages that expect an \code{AzureToken} object.

If the token is a JWT (JSON Web Token), the class will attempt to parse it to extract
metadata such as the tenant ID, audience (resource), and expiration time. If parsing
fails (e.g., for opaque tokens), the class will still function but with limited metadata.

Since manual tokens are managed externally, the \code{refresh()} method cannot obtain
a new token. When the token expires, you must create a new \code{AzureManualToken}
object with a fresh token string.

\code{get_manual_token} is a convenience function that creates an \code{AzureManualToken} object.
}
\section{Methods}{

\itemize{
  \item \code{new(token, type, tenant, resource)}: Initialize a new manual token object.
  \item \code{refresh()}: Cannot refresh a manual token; issues a warning and returns self.
  \item \code{validate()}: Checks if the token has expired based on JWT claims.
  \item \code{can_refresh()}: Returns FALSE since manual tokens cannot be refreshed.
  \item \code{cache()}: No-op; manual tokens are not cached.
}
}

\section{Token sources}{

Common ways to obtain tokens externally include:
\itemize{
  \item Azure CLI: \code{az account get-access-token --resource <resource>}
  \item Azure PowerShell: \code{Get-AzAccessToken -ResourceUrl <resource>}
  \item Python (azure-identity): \code{DefaultAzureCredential().get_token(<scope>)}
  \item MSAL libraries in various languages
}
}

\section{Limitations}{

Manual tokens have the following limitations compared to tokens obtained via
\code{\link{get_azure_token}}:
\itemize{
  \item Cannot be automatically refreshed when they expire
  \item Are not cached to disk
  \item May have incomplete metadata if JWT parsing fails
}
}

\examples{
\dontrun{
# Get a token externally (e.g., from Azure CLI)
# az account get-access-token --resource https://graph.microsoft.com
raw_token <- "eyJ0eXAiOiJKV1QiLC..."

# Create a manual token object
token <- get_manual_token(raw_token)

# Check if metadata was parsed
print(token$tenant)
print(token$resource)

# Use with AzureGraph
library(AzureGraph)
gr <- ms_graph$new(token = token)
me <- gr$get_user("me")

# Check token validity
token$validate()

# For opaque tokens, provide metadata explicitly
token2 <- get_manual_token(
    token = "opaque_token_string",
    tenant = "your-tenant-id",
    resource = "https://management.azure.com/"
)
}
}
\seealso{
\code{\link{AzureToken}}, \code{\link{get_azure_token}}, \code{\link{decode_jwt}}
}
